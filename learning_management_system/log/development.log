  [1m[35m (1.1ms)[0m  [1m[35mCREATE DATABASE "learning_management_system_development" ENCODING = 'unicode'[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE "learning_management_system_test" ENCODING = 'unicode'[0m
Started GET "/" for ::1 at 2025-08-09 09:14:03 +0300
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
Processing by Rails::WelcomeController#index as HTML
  Rendering /Users/aleksey.volobuyev/.rvm/gems/ruby-3.2.3/gems/railties-7.1.5.1/lib/rails/templates/rails/welcome/index.html.erb
  Rendered /Users/aleksey.volobuyev/.rvm/gems/ruby-3.2.3/gems/railties-7.1.5.1/lib/rails/templates/rails/welcome/index.html.erb (Duration: 0.5ms | Allocations: 376)
Completed 200 OK in 17ms (Views: 4.8ms | ActiveRecord: 0.0ms | Allocations: 7887)


  [1m[35m (0.5ms)[0m  [1m[34mSELECT pg_try_advisory_lock(8108197722675921990)[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.0ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.9ms)[0m  [1m[34mSELECT * FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 ORDER BY "ar_internal_metadata"."key" ASC LIMIT 1[0m  [[nil, "environment"]]
  [1m[36mActiveRecord::InternalMetadata Create (2.7ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ('environment', 'development', '2025-08-09 06:24:01.460051', '2025-08-09 06:24:01.460055') RETURNING "key"[0m
Migrating to SequentInitialSchema (20250809092310)
  [1m[35m (0.4ms)[0m  [1m[34mSELECT pg_advisory_unlock(8108197722675921990)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT pg_try_advisory_lock(8108197722675921990)[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.8ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.1ms)[0m  [1m[34mSELECT * FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 ORDER BY "ar_internal_metadata"."key" ASC LIMIT 1[0m  [[nil, "environment"]]
Migrating to SequentInitialSchema (20250809092310)
  [1m[36mTRANSACTION (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE SCHEMA IF NOT EXISTS "sequent_schema"[0m
  [1m[35m (0.2ms)[0m  [1m[35mCREATE SCHEMA IF NOT EXISTS "view_schema"[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT current_setting('search_path')[0m
  [1m[36mwith_search_path (0.1ms)[0m  [1m[35mSET search_path TO sequent_schema[0m
  [1m[35m (44.2ms)[0m  [1m[35mCREATE TABLE command_types (id SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, type text UNIQUE NOT NULL);
CREATE TABLE aggregate_types (id SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, type text UNIQUE NOT NULL);
CREATE TABLE event_types (id SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, type text UNIQUE NOT NULL);

CREATE TABLE commands (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone NOT NULL,
    user_id uuid,
    aggregate_id uuid,
    command_type_id SMALLINT NOT NULL,
    command_json jsonb NOT NULL,
    event_aggregate_id uuid,
    event_sequence_number integer,
    FOREIGN KEY (command_type_id) REFERENCES command_types (id) ON UPDATE CASCADE
) PARTITION BY RANGE (id);

CREATE TABLE aggregates (
    aggregate_id uuid NOT NULL PRIMARY KEY,
    events_partition_key text NOT NULL DEFAULT '',
    aggregate_type_id SMALLINT NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT NOW(),
    UNIQUE (events_partition_key, aggregate_id),
    FOREIGN KEY (aggregate_type_id) REFERENCES aggregate_types (id) ON UPDATE CASCADE
) PARTITION BY RANGE (aggregate_id);

CREATE TABLE aggregate_unique_keys (
    aggregate_id uuid NOT NULL,
    scope text NOT NULL,
    key jsonb NOT NULL,
    PRIMARY KEY (aggregate_id, scope),
    UNIQUE (scope, key),
    FOREIGN KEY (aggregate_id) REFERENCES aggregates (aggregate_id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE events (
  aggregate_id uuid NOT NULL,
  partition_key text NOT NULL DEFAULT '',
  sequence_number integer NOT NULL,
  created_at timestamp with time zone NOT NULL,
  command_id bigint NOT NULL,
  event_type_id SMALLINT NOT NULL,
  event_json jsonb NOT NULL,
  xact_id bigint DEFAULT pg_current_xact_id()::text::bigint,
  PRIMARY KEY (partition_key, aggregate_id, sequence_number),
  FOREIGN KEY (partition_key, aggregate_id) REFERENCES aggregates (events_partition_key, aggregate_id)
       ON UPDATE CASCADE ON DELETE RESTRICT,
  FOREIGN KEY (command_id) REFERENCES commands (id) ON UPDATE RESTRICT ON DELETE RESTRICT,
  FOREIGN KEY (event_type_id) REFERENCES event_types (id) ON UPDATE CASCADE
) PARTITION BY RANGE (partition_key);

CREATE TABLE aggregates_that_need_snapshots (
  aggregate_id uuid NOT NULL PRIMARY KEY,
  snapshot_sequence_number_high_water_mark integer,
  snapshot_outdated_at timestamp with time zone,
  snapshot_scheduled_at timestamp with time zone,
  FOREIGN KEY (aggregate_id) REFERENCES aggregates (aggregate_id) ON UPDATE CASCADE ON DELETE CASCADE
);

COMMENT ON TABLE aggregates_that_need_snapshots IS 'Contains a row for every aggregate with more events than its snapshot threshold.';
COMMENT ON COLUMN aggregates_that_need_snapshots.snapshot_sequence_number_high_water_mark
  IS 'The highest sequence number of the stored snapshot. Kept when snapshot are deleted to more easily query aggregates that need snapshotting the most';
COMMENT ON COLUMN aggregates_that_need_snapshots.snapshot_outdated_at IS 'Not NULL indicates a snapshot is needed since the stored timestamp';
COMMENT ON COLUMN aggregates_that_need_snapshots.snapshot_scheduled_at IS 'Not NULL indicates a snapshot is in the process of being taken';

CREATE TABLE snapshot_records (
  aggregate_id uuid NOT NULL,
  sequence_number integer NOT NULL,
  created_at timestamptz NOT NULL,
  snapshot_type text NOT NULL,
  snapshot_json jsonb NOT NULL,
  PRIMARY KEY (aggregate_id, sequence_number),
  FOREIGN KEY (aggregate_id) REFERENCES aggregates_that_need_snapshots (aggregate_id)
       ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE saved_event_records (
  operation varchar(1) NOT NULL CHECK (operation IN ('U', 'D')),
  timestamp timestamptz NOT NULL,
  "user" text NOT NULL,
  aggregate_id uuid NOT NULL,
  partition_key text DEFAULT '',
  sequence_number integer NOT NULL,
  created_at timestamp with time zone NOT NULL,
  command_id bigint NOT NULL,
  event_type text NOT NULL,
  event_json jsonb NOT NULL,
  xact_id bigint,
  PRIMARY KEY (aggregate_id, sequence_number, timestamp)
);
[0m
  [1m[35m (11.1ms)[0m  [1m[35m-- ### Configure partitions as needed
CREATE TABLE commands_default PARTITION OF commands DEFAULT;
-- CREATE TABLE commands_0 PARTITION OF commands FOR VALUES FROM (1) TO (100e6);
-- CREATE TABLE commands_1 PARTITION OF commands FOR VALUES FROM (100e6) TO (200e6);
-- CREATE TABLE commands_2 PARTITION OF commands FOR VALUES FROM (200e6) TO (300e6);
-- CREATE TABLE commands_3 PARTITION OF commands FOR VALUES FROM (300e6) TO (400e6);

-- ### Configure partitions as needed
CREATE TABLE aggregates_default PARTITION OF aggregates DEFAULT;
-- CREATE TABLE aggregates_0 PARTITION OF aggregates FOR VALUES FROM (MINVALUE) TO ('10000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_1 PARTITION OF aggregates FOR VALUES FROM ('10000000-0000-0000-0000-000000000000') TO ('20000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_2 PARTITION OF aggregates FOR VALUES FROM ('20000000-0000-0000-0000-000000000000') TO ('30000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_3 PARTITION OF aggregates FOR VALUES FROM ('30000000-0000-0000-0000-000000000000') TO ('40000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_4 PARTITION OF aggregates FOR VALUES FROM ('40000000-0000-0000-0000-000000000000') TO ('50000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_5 PARTITION OF aggregates FOR VALUES FROM ('50000000-0000-0000-0000-000000000000') TO ('60000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_6 PARTITION OF aggregates FOR VALUES FROM ('60000000-0000-0000-0000-000000000000') TO ('70000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_7 PARTITION OF aggregates FOR VALUES FROM ('70000000-0000-0000-0000-000000000000') TO ('80000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_8 PARTITION OF aggregates FOR VALUES FROM ('80000000-0000-0000-0000-000000000000') TO ('90000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_9 PARTITION OF aggregates FOR VALUES FROM ('90000000-0000-0000-0000-000000000000') TO ('a0000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_a PARTITION OF aggregates FOR VALUES FROM ('a0000000-0000-0000-0000-000000000000') TO ('b0000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_b PARTITION OF aggregates FOR VALUES FROM ('b0000000-0000-0000-0000-000000000000') TO ('c0000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_c PARTITION OF aggregates FOR VALUES FROM ('c0000000-0000-0000-0000-000000000000') TO ('d0000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_d PARTITION OF aggregates FOR VALUES FROM ('d0000000-0000-0000-0000-000000000000') TO ('e0000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_e PARTITION OF aggregates FOR VALUES FROM ('e0000000-0000-0000-0000-000000000000') TO ('f0000000-0000-0000-0000-000000000000');
-- CREATE TABLE aggregates_f PARTITION OF aggregates FOR VALUES FROM ('f0000000-0000-0000-0000-000000000000') TO (MAXVALUE);

-- ### Configure partitions as needed
CREATE TABLE events_default PARTITION OF events DEFAULT;
-- CREATE TABLE events_2023_and_earlier PARTITION OF events FOR VALUES FROM ('Y00') TO ('Y24');
-- CREATE TABLE events_2024 PARTITION OF events FOR VALUES FROM ('Y24') TO ('Y25');
-- CREATE TABLE events_2025 PARTITION OF events FOR VALUES FROM ('Y25') TO ('Y26');
-- CREATE TABLE events_2026 PARTITION OF events FOR VALUES FROM ('Y26') TO ('Y27');
-- CREATE TABLE events_2027_and_later PARTITION OF events FOR VALUES FROM ('Y27') TO ('Y99');
-- CREATE TABLE events_aggregate PARTITION OF events FOR VALUES FROM ('A') TO ('Ag');
[0m
  [1m[35m (7.8ms)[0m  [1m[35mCREATE INDEX aggregates_aggregate_type_id_idx ON aggregates (aggregate_type_id);
CREATE INDEX commands_command_type_id_idx ON commands (command_type_id);
CREATE INDEX commands_aggregate_id_idx ON commands (aggregate_id);
CREATE INDEX commands_event_idx ON commands (event_aggregate_id, event_sequence_number);
CREATE INDEX events_command_id_idx ON events (command_id);
CREATE INDEX events_event_type_id_idx ON events (event_type_id);
CREATE INDEX aggregates_that_need_snapshots_outdated_idx
          ON aggregates_that_need_snapshots (snapshot_outdated_at ASC, snapshot_sequence_number_high_water_mark DESC, aggregate_id ASC)
       WHERE snapshot_outdated_at IS NOT NULL;

[0m
  [1m[36mwith_search_path (0.3ms)[0m  [1m[35mSET search_path TO public, view_schema, sequent_schema[0m
  [1m[36mActiveRecord::SchemaMigration Create (0.8ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ('20250809092310') RETURNING "version"[0m
  [1m[36mTRANSACTION (1.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to SequentStoredProcedures (20250809092311)
  [1m[36mTRANSACTION (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.8ms)[0m  [1m[34mSELECT current_setting('search_path')[0m
  [1m[36mwith_search_path (0.2ms)[0m  [1m[35mSET search_path TO sequent_schema[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE TYPE aggregate_event_type AS (
  aggregate_type text,
  aggregate_id uuid,
  events_partition_key text,
  event_type text,
  event_json jsonb
);
[0m
  [1m[35m (47.2ms)[0m  [1m[35mCREATE OR REPLACE FUNCTION enrich_command_json(command commands) RETURNS jsonb RETURNS NULL ON NULL INPUT
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  RETURN jsonb_build_object(
      'command_type', (SELECT type FROM command_types WHERE command_types.id = command.command_type_id),
      'created_at', command.created_at,
      'user_id', command.user_id,
      'aggregate_id', command.aggregate_id,
      'event_aggregate_id', command.event_aggregate_id,
      'event_sequence_number', command.event_sequence_number
    )
    || command.command_json;
END
$$;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mCREATE OR REPLACE FUNCTION aggregates_that_need_snapshots(_last_aggregate_id uuid, _limit integer)
  RETURNS TABLE (aggregate_id uuid)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  RETURN QUERY SELECT a.aggregate_id
    FROM aggregates_that_need_snapshots a
   WHERE a.snapshot_outdated_at IS NOT NULL
     AND (_last_aggregate_id IS NULL OR a.aggregate_id > _last_aggregate_id)
   ORDER BY 1
   LIMIT _limit;
END;
$$;
[0m
  [1m[35m (3.5ms)[0m  [1m[35mDROP VIEW IF EXISTS command_records;
CREATE VIEW command_records (id, user_id, aggregate_id, command_type, command_json, created_at, event_aggregate_id, event_sequence_number) AS
  SELECT id,
         user_id,
         aggregate_id,
         (SELECT type FROM command_types WHERE command_types.id = command.command_type_id),
         enrich_command_json(command),
         created_at,
         event_aggregate_id,
         event_sequence_number
    FROM commands command;
[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE delete_all_snapshots(_now timestamp with time zone DEFAULT NOW())
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  UPDATE aggregates_that_need_snapshots
     SET snapshot_outdated_at = _now
   WHERE snapshot_outdated_at IS NULL;
  DELETE FROM snapshot_records;
END;
$$;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE delete_snapshots_before(_aggregate_id uuid, _sequence_number integer, _now timestamp with time zone DEFAULT NOW())
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  DELETE FROM snapshot_records
   WHERE aggregate_id = _aggregate_id
     AND sequence_number < _sequence_number;

  UPDATE aggregates_that_need_snapshots
     SET snapshot_outdated_at = _now
   WHERE aggregate_id = _aggregate_id
     AND snapshot_outdated_at IS NULL
     AND NOT EXISTS (SELECT 1 FROM snapshot_records WHERE aggregate_id = _aggregate_id);
END;
$$;
[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE OR REPLACE FUNCTION enrich_event_json(event events) RETURNS jsonb RETURNS NULL ON NULL INPUT
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  RETURN jsonb_build_object(
      'aggregate_id', event.aggregate_id,
      'sequence_number', event.sequence_number,
      'created_at', event.created_at
    )
    || event.event_json;
END
$$;
[0m
  [1m[35m (3.6ms)[0m  [1m[35mDROP VIEW IF EXISTS event_records;
CREATE VIEW event_records (aggregate_id, partition_key, sequence_number, created_at, event_type, event_json, command_record_id, xact_id) AS
     SELECT aggregate.aggregate_id,
            event.partition_key,
            event.sequence_number,
            event.created_at,
            type.type,
            enrich_event_json(event) AS event_json,
            command_id,
            event.xact_id
       FROM events event
       JOIN aggregates aggregate ON aggregate.aggregate_id = event.aggregate_id AND aggregate.events_partition_key = event.partition_key
       JOIN event_types type ON event.event_type_id = type.id;
[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE OR REPLACE FUNCTION load_event(
  _aggregate_id uuid,
  _sequence_number integer
) RETURNS SETOF aggregate_event_type RETURNS NULL ON NULL INPUT
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  RETURN QUERY SELECT aggregate_types.type,
         a.aggregate_id,
         a.events_partition_key,
         event_types.type,
         enrich_event_json(e)
    FROM aggregates a
        INNER JOIN events e ON (a.events_partition_key, a.aggregate_id) = (e.partition_key, e.aggregate_id)
        INNER JOIN aggregate_types ON a.aggregate_type_id = aggregate_types.id
        INNER JOIN event_types ON e.event_type_id = event_types.id
   WHERE a.aggregate_id = _aggregate_id
     AND e.sequence_number = _sequence_number;
END;
$$;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mCREATE OR REPLACE FUNCTION load_events(
  _aggregate_ids jsonb,
  _use_snapshots boolean DEFAULT TRUE,
  _until timestamptz DEFAULT NULL
) RETURNS SETOF aggregate_event_type
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
DECLARE
  _aggregate_id aggregates.aggregate_id%TYPE;
BEGIN
  FOR _aggregate_id IN SELECT * FROM jsonb_array_elements_text(_aggregate_ids) LOOP
    -- Use a single query to avoid race condition with UPDATEs to the events partition key
    -- in case transaction isolation level is lower than repeatable read (the default of
    -- PostgreSQL is read committed).
    RETURN QUERY WITH
      aggregate AS (
        SELECT aggregate_types.type, aggregate_id, events_partition_key
          FROM aggregates
          JOIN aggregate_types ON aggregate_type_id = aggregate_types.id
         WHERE aggregate_id = _aggregate_id
      ),
      snapshot AS (
        SELECT *
          FROM snapshot_records
         WHERE _use_snapshots
           AND aggregate_id = _aggregate_id
           AND (_until IS NULL OR created_at < _until)
         ORDER BY sequence_number DESC LIMIT 1
      )
    (SELECT a.*, s.snapshot_type, s.snapshot_json FROM aggregate a, snapshot s)
    UNION ALL
    (SELECT a.*, event_types.type, enrich_event_json(e)
       FROM aggregate a
       JOIN events e ON (a.events_partition_key, a.aggregate_id) = (e.partition_key, e.aggregate_id)
       JOIN event_types ON e.event_type_id = event_types.id
      WHERE e.sequence_number >= COALESCE((SELECT sequence_number FROM snapshot), 0)
        AND (_until IS NULL OR e.created_at < _until)
      ORDER BY e.sequence_number ASC);
  END LOOP;
END;
$$;
[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE OR REPLACE FUNCTION load_latest_snapshot(_aggregate_id uuid) RETURNS aggregate_event_type
LANGUAGE SQL SET search_path FROM CURRENT AS $$
  SELECT (SELECT type FROM aggregate_types WHERE id = a.aggregate_type_id),
         a.aggregate_id,
         a.events_partition_key,
         s.snapshot_type,
         s.snapshot_json
    FROM aggregates a JOIN snapshot_records s ON a.aggregate_id = s.aggregate_id
   WHERE a.aggregate_id = _aggregate_id
   ORDER BY s.sequence_number DESC
   LIMIT 1;
$$;
[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP PROCEDURE IF EXISTS permanently_delete_commands_without_events(uuid, uuid);
CREATE OR REPLACE PROCEDURE permanently_delete_commands_without_events(_aggregate_id uuid)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  IF _aggregate_id IS NULL THEN
    RAISE EXCEPTION 'aggregate_id must be specified to delete commands';
  END IF;

  DELETE FROM commands
   WHERE aggregate_id = _aggregate_id
     AND NOT EXISTS (SELECT 1 FROM events WHERE command_id = commands.id);
END;
$$;
[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE permanently_delete_event_streams(_aggregate_ids jsonb)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  DELETE FROM events
   USING jsonb_array_elements_text(_aggregate_ids) AS ids (id)
    JOIN aggregates ON ids.id::uuid = aggregates.aggregate_id
   WHERE events.partition_key = aggregates.events_partition_key
     AND events.aggregate_id = aggregates.aggregate_id;
  DELETE FROM aggregates
   USING jsonb_array_elements_text(_aggregate_ids) AS ids (id)
   WHERE aggregates.aggregate_id = ids.id::uuid;
END;
$$;
[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE OR REPLACE FUNCTION save_events_on_delete_trigger() RETURNS TRIGGER
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  INSERT INTO saved_event_records (operation, timestamp, "user", aggregate_id, partition_key, sequence_number, created_at, event_type, event_json, command_id, xact_id)
  SELECT 'D',
         statement_timestamp(),
         user,
         o.aggregate_id,
         o.partition_key,
         o.sequence_number,
         o.created_at,
         (SELECT type FROM event_types WHERE event_types.id = o.event_type_id),
         o.event_json,
         o.command_id,
         o.xact_id
    FROM old_table o;
  RETURN NULL;
END;
$$;

CREATE OR REPLACE FUNCTION save_events_on_update_trigger() RETURNS TRIGGER
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  INSERT INTO saved_event_records (operation, timestamp, "user", aggregate_id, partition_key, sequence_number, created_at, event_type, event_json, command_id, xact_id)
  SELECT 'U',
         statement_timestamp(),
         user,
         o.aggregate_id,
         o.partition_key,
         o.sequence_number,
         o.created_at,
         (SELECT type FROM event_types WHERE event_types.id = o.event_type_id),
         o.event_json,
         o.command_id,
         o.xact_id
    FROM old_table o LEFT JOIN new_table n ON o.aggregate_id = n.aggregate_id AND o.sequence_number = n.sequence_number
   WHERE n IS NULL
      -- Only save when event related information changes
      OR o.created_at <> n.created_at
      OR o.event_type_id <> n.event_type_id
      OR o.event_json <> n.event_json;
  RETURN NULL;
END;
$$;

CREATE OR REPLACE TRIGGER save_events_on_delete_trigger
    AFTER DELETE ON events
    REFERENCING OLD TABLE AS old_table
    FOR EACH STATEMENT EXECUTE FUNCTION save_events_on_delete_trigger();
CREATE OR REPLACE TRIGGER save_events_on_update_trigger
    AFTER UPDATE ON events
    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION save_events_on_update_trigger();
[0m
  [1m[35m (0.6ms)[0m  [1m[37mCREATE OR REPLACE FUNCTION select_aggregates_for_snapshotting(_limit integer, _reschedule_snapshot_scheduled_before timestamp with time zone, _now timestamp with time zone DEFAULT NOW())
  RETURNS TABLE (aggregate_id uuid)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  RETURN QUERY WITH scheduled AS MATERIALIZED (
    SELECT a.aggregate_id
      FROM aggregates_that_need_snapshots AS a
     WHERE snapshot_outdated_at IS NOT NULL
     ORDER BY snapshot_outdated_at ASC, snapshot_sequence_number_high_water_mark DESC, aggregate_id ASC
     LIMIT _limit
       FOR UPDATE
   ) UPDATE aggregates_that_need_snapshots AS row
        SET snapshot_scheduled_at = _now
       FROM scheduled
      WHERE row.aggregate_id = scheduled.aggregate_id
        AND (row.snapshot_scheduled_at IS NULL OR row.snapshot_scheduled_at < _reschedule_snapshot_scheduled_before)
    RETURNING row.aggregate_id;
END;
$$;
[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE store_aggregates(_aggregates_with_events jsonb)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
DECLARE
  _aggregate jsonb;
  _events jsonb;
  _aggregate_id aggregates.aggregate_id%TYPE;
  _events_partition_key aggregates.events_partition_key%TYPE;
  _snapshot_outdated_at aggregates_that_need_snapshots.snapshot_outdated_at%TYPE;
BEGIN
  FOR _aggregate, _events IN SELECT row->0, row->1 FROM jsonb_array_elements(_aggregates_with_events) AS row LOOP
    _aggregate_id = _aggregate->>'aggregate_id';

    _events_partition_key = COALESCE(
      _aggregate->>'events_partition_key',
      (SELECT events_partition_key FROM aggregates WHERE aggregate_id = _aggregate_id),
      ''
    );

    INSERT INTO aggregates (aggregate_id, created_at, aggregate_type_id, events_partition_key)
    VALUES (
      _aggregate_id,
      (_events->0->>'created_at')::timestamptz,
      (SELECT id FROM aggregate_types WHERE type = _aggregate->>'aggregate_type'),
      _events_partition_key
    ) ON CONFLICT (aggregate_id)
      DO UPDATE SET events_partition_key = EXCLUDED.events_partition_key
              WHERE aggregates.events_partition_key IS DISTINCT FROM EXCLUDED.events_partition_key;

    _snapshot_outdated_at = _aggregate->>'snapshot_outdated_at';
    IF _snapshot_outdated_at IS NOT NULL THEN
      INSERT INTO aggregates_that_need_snapshots AS row (aggregate_id, snapshot_outdated_at)
      VALUES (_aggregate_id, _snapshot_outdated_at)
          ON CONFLICT (aggregate_id) DO UPDATE
         SET snapshot_outdated_at = LEAST(row.snapshot_outdated_at, EXCLUDED.snapshot_outdated_at)
       WHERE row.snapshot_outdated_at IS DISTINCT FROM EXCLUDED.snapshot_outdated_at;
    END IF;
  END LOOP;
END;
$$;
[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE OR REPLACE FUNCTION store_command(_command jsonb) RETURNS bigint RETURNS NULL ON NULL INPUT
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
DECLARE
  _id commands.id%TYPE;
  _command_json jsonb = _command->'command_json';
BEGIN
  INSERT INTO commands (
    created_at, user_id, aggregate_id, command_type_id, command_json,
    event_aggregate_id, event_sequence_number
  ) VALUES (
    (_command->>'created_at')::timestamptz,
    (_command_json->>'user_id')::uuid,
    (_command_json->>'aggregate_id')::uuid,
    (SELECT id FROM command_types WHERE type = _command->>'command_type'),
    (_command->'command_json') - '{command_type,created_at,user_id,aggregate_id,event_aggregate_id,event_sequence_number}'::text[],
    (_command_json->>'event_aggregate_id')::uuid,
    NULLIF(_command_json->'event_sequence_number', 'null'::jsonb)::integer
  ) RETURNING id INTO STRICT _id;
  RETURN _id;
END;
$$;
[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE store_events(_command jsonb, _aggregates_with_events jsonb)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
DECLARE
  _command_id commands.id%TYPE;
  _aggregates jsonb;
  _aggregate jsonb;
  _events jsonb;
  _aggregate_id aggregates.aggregate_id%TYPE;
  _events_partition_key aggregates.events_partition_key%TYPE;
BEGIN
  CALL update_types(_command, _aggregates_with_events);

  _command_id = store_command(_command);

  CALL store_aggregates(_aggregates_with_events);

  _aggregates = (SELECT jsonb_agg(row->0) FROM jsonb_array_elements(_aggregates_with_events) AS row);
  CALL update_unique_keys(_aggregates);

  FOR _aggregate, _events IN SELECT row->0, row->1 FROM jsonb_array_elements(_aggregates_with_events) AS row
                             ORDER BY row->0->'aggregate_id', row->1->0->'event_json'->'sequence_number'
  LOOP
    _aggregate_id = _aggregate->>'aggregate_id';
    SELECT events_partition_key INTO STRICT _events_partition_key FROM aggregates WHERE aggregate_id = _aggregate_id;

    INSERT INTO events (partition_key, aggregate_id, sequence_number, created_at, command_id, event_type_id, event_json)
    SELECT _events_partition_key,
           _aggregate_id,
           (event->'event_json'->'sequence_number')::integer,
           (event->>'created_at')::timestamptz,
           _command_id,
           (SELECT id FROM event_types WHERE type = event->>'event_type'),
           (event->'event_json') - '{aggregate_id,created_at,event_type,sequence_number}'::text[]
      FROM jsonb_array_elements(_events) AS event;
  END LOOP;
END;
$$;
[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE store_snapshots(_snapshots jsonb)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
DECLARE
  _aggregate_id uuid;
  _snapshot jsonb;
  _sequence_number snapshot_records.sequence_number%TYPE;
BEGIN
  FOR _snapshot IN SELECT * FROM jsonb_array_elements(_snapshots) LOOP
    _aggregate_id = _snapshot->>'aggregate_id';
    _sequence_number = _snapshot->'sequence_number';

    INSERT INTO aggregates_that_need_snapshots AS row (aggregate_id, snapshot_sequence_number_high_water_mark)
    VALUES (_aggregate_id, _sequence_number)
        ON CONFLICT (aggregate_id) DO UPDATE
       SET snapshot_sequence_number_high_water_mark =
             GREATEST(row.snapshot_sequence_number_high_water_mark, EXCLUDED.snapshot_sequence_number_high_water_mark),
           snapshot_outdated_at = NULL,
           snapshot_scheduled_at = NULL;

    INSERT INTO snapshot_records (aggregate_id, sequence_number, created_at, snapshot_type, snapshot_json)
    VALUES (
      _aggregate_id,
      _sequence_number,
      (_snapshot->>'created_at')::timestamptz,
      _snapshot->>'snapshot_type',
      _snapshot->'snapshot_json'
    );
  END LOOP;
END;
$$;
[0m
  [1m[35m (2.3ms)[0m  [1m[35mDROP VIEW IF EXISTS stream_records;
CREATE VIEW stream_records (aggregate_id, events_partition_key, aggregate_type, created_at) AS
     SELECT aggregates.aggregate_id,
            aggregates.events_partition_key,
            aggregate_types.type,
            aggregates.created_at
       FROM aggregates JOIN aggregate_types ON aggregates.aggregate_type_id = aggregate_types.id;
[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE update_types(_command jsonb, _aggregates_with_events jsonb)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM command_types t WHERE t.type = _command->>'command_type') THEN
    -- Only try inserting if it doesn't exist to avoid exhausting the id sequence
    INSERT INTO command_types (type)
    VALUES (_command->>'command_type')
     ON CONFLICT DO NOTHING;
  END IF;

  WITH types AS (
    SELECT DISTINCT row->0->>'aggregate_type' AS type
      FROM jsonb_array_elements(_aggregates_with_events) AS row
  )
  INSERT INTO aggregate_types (type)
  SELECT type FROM types
   WHERE type NOT IN (SELECT type FROM aggregate_types)
   ORDER BY 1
      ON CONFLICT DO NOTHING;

  WITH types AS (
    SELECT DISTINCT events->>'event_type' AS type
      FROM jsonb_array_elements(_aggregates_with_events) AS row
           CROSS JOIN LATERAL jsonb_array_elements(row->1) AS events
  )
  INSERT INTO event_types (type)
  SELECT type FROM types
   WHERE type NOT IN (SELECT type FROM event_types)
   ORDER BY 1
      ON CONFLICT DO NOTHING;
END;
$$;
[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE update_unique_keys(_stream_records jsonb)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
DECLARE
  _aggregate jsonb;
  _aggregate_id aggregates.aggregate_id%TYPE;
  _unique_keys jsonb;
BEGIN
  FOR _aggregate IN SELECT aggregate FROM jsonb_array_elements(_stream_records) AS aggregate LOOP
    _aggregate_id = _aggregate->>'aggregate_id';
    _unique_keys = COALESCE(_aggregate->'unique_keys', '{}'::jsonb);

    DELETE FROM aggregate_unique_keys AS target
     WHERE target.aggregate_id = _aggregate_id
       AND NOT (_unique_keys ? target.scope);
  END LOOP;

  FOR _aggregate IN SELECT aggregate FROM jsonb_array_elements(_stream_records) AS aggregate LOOP
    _aggregate_id = _aggregate->>'aggregate_id';
    _unique_keys = COALESCE(_aggregate->'unique_keys', '{}'::jsonb);

    INSERT INTO aggregate_unique_keys AS target (aggregate_id, scope, key)
    SELECT _aggregate_id, key, value
      FROM jsonb_each(_unique_keys) AS x
        ON CONFLICT (aggregate_id, scope) DO UPDATE
       SET key = EXCLUDED.key
     WHERE target.key <> EXCLUDED.key;
  END LOOP;
EXCEPTION
  WHEN unique_violation THEN
    RAISE unique_violation
    USING MESSAGE = 'duplicate unique key value for aggregate ' || (_aggregate->>'aggregate_type') || ' ' || _aggregate_id || ' (' || SQLERRM || ')';
END;
$$;
[0m
  [1m[36mwith_search_path (0.2ms)[0m  [1m[35mSET search_path TO public, view_schema, sequent_schema[0m
  [1m[36mActiveRecord::SchemaMigration Create (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ('20250809092311') RETURNING "version"[0m
  [1m[36mTRANSACTION (1.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to SequentStoreEventsV02 (20250809092312)
  [1m[36mTRANSACTION (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.7ms)[0m  [1m[34mSELECT current_setting('search_path')[0m
  [1m[36mwith_search_path (0.2ms)[0m  [1m[35mSET search_path TO sequent_schema[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE OR REPLACE PROCEDURE store_events(_command jsonb, _aggregates_with_events jsonb)
LANGUAGE plpgsql SET search_path FROM CURRENT AS $$
DECLARE
  _command_id commands.id%TYPE;
  _aggregates jsonb;
  _aggregate jsonb;
  _events jsonb;
  _aggregate_id aggregates.aggregate_id%TYPE;
  _events_partition_key aggregates.events_partition_key%TYPE;
BEGIN
  CALL update_types(_command, _aggregates_with_events);

  _command_id = store_command(_command);

  CALL store_aggregates(_aggregates_with_events);

  FOR _aggregate, _events IN SELECT row->0, row->1 FROM jsonb_array_elements(_aggregates_with_events) AS row
                             ORDER BY row->0->'aggregate_id', row->1->0->'event_json'->'sequence_number'
  LOOP
    _aggregate_id = _aggregate->>'aggregate_id';
    SELECT events_partition_key INTO STRICT _events_partition_key FROM aggregates WHERE aggregate_id = _aggregate_id;

    INSERT INTO events (partition_key, aggregate_id, sequence_number, created_at, command_id, event_type_id, event_json)
    SELECT _events_partition_key,
           _aggregate_id,
           (event->'event_json'->'sequence_number')::integer,
           (event->>'created_at')::timestamptz,
           _command_id,
           (SELECT id FROM event_types WHERE type = event->>'event_type'),
           (event->'event_json') - '{aggregate_id,created_at,event_type,sequence_number}'::text[]
      FROM jsonb_array_elements(_events) AS event;
  END LOOP;

  _aggregates = (SELECT jsonb_agg(row->0) FROM jsonb_array_elements(_aggregates_with_events) AS row);
  CALL update_unique_keys(_aggregates);
END;
$$;
[0m
  [1m[36mwith_search_path (0.1ms)[0m  [1m[35mSET search_path TO public, view_schema, sequent_schema[0m
  [1m[36mActiveRecord::SchemaMigration Create (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ('20250809092312') RETURNING "version"[0m
  [1m[36mTRANSACTION (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT pg_advisory_unlock(8108197722675921990)[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.2ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (1336.5ms)[0m  [1m[35mCREATE SCHEMA IF NOT EXISTS view_schema[0m
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT current_setting('search_path')[0m
  [1m[36mwith_search_path (0.2ms)[0m  [1m[35mSET search_path TO view_schema[0m
  [1m[35m (3.6ms)[0m  [1m[35mCREATE TABLE IF NOT EXISTS sequent_versions (version integer NOT NULL, CONSTRAINT version_pk PRIMARY KEY(version));
ALTER TABLE sequent_versions drop constraint if exists only_one_running;
ALTER TABLE sequent_versions ADD COLUMN IF NOT EXISTS status INTEGER DEFAULT NULL CONSTRAINT only_one_running CHECK (status in (1,2,3));
ALTER TABLE sequent_versions ADD COLUMN IF NOT EXISTS xmin_xact_id BIGINT;
DROP INDEX IF EXISTS single_migration_running;
CREATE UNIQUE INDEX single_migration_running ON sequent_versions ((status * 0)) where status is not null;[0m
  [1m[36mwith_search_path (0.2ms)[0m  [1m[35mSET search_path TO public, view_schema, sequent_schema[0m
  [1m[36mTRANSACTION (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1317.9ms)[0m  [1m[34mSELECT current_setting('search_path')[0m
  [1m[36mwith_search_path (0.2ms)[0m  [1m[35mSET search_path TO view_schema[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE TABLE IF NOT EXISTS sequent_versions (version integer NOT NULL, CONSTRAINT version_pk PRIMARY KEY(version));
ALTER TABLE sequent_versions drop constraint if exists only_one_running;
ALTER TABLE sequent_versions ADD COLUMN IF NOT EXISTS status INTEGER DEFAULT NULL CONSTRAINT only_one_running CHECK (status in (1,2,3));
ALTER TABLE sequent_versions ADD COLUMN IF NOT EXISTS xmin_xact_id BIGINT;
DROP INDEX IF EXISTS single_migration_running;
CREATE UNIQUE INDEX single_migration_running ON sequent_versions ((status * 0)) where status is not null;[0m
  [1m[36mwith_search_path (0.2ms)[0m  [1m[35mSET search_path TO public, view_schema, sequent_schema[0m
  [1m[36mTRANSACTION (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSequent::Migrations::Versions Load (1.2ms)[0m  [1m[34mSELECT "sequent_versions".* FROM "sequent_versions" WHERE "sequent_versions"."status" IS NULL ORDER BY version desc LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mSequent::Migrations::Versions Load (0.5ms)[0m  [1m[34mSELECT "sequent_versions".* FROM "sequent_versions" WHERE "sequent_versions"."status" IS NULL ORDER BY version desc LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mSequent::Migrations::Versions Load (1.9ms)[0m  [1m[34mSELECT "sequent_versions".* FROM "sequent_versions" WHERE "sequent_versions"."status" IS NULL ORDER BY version desc LIMIT $1[0m  [["LIMIT", 1]]
Started GET "/" for ::1 at 2025-08-09 09:27:23 +0300
  [1m[36mActiveRecord::SchemaMigration Load (1.0ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
Processing by Rails::WelcomeController#index as HTML
  Rendering /Users/aleksey.volobuyev/.rvm/gems/ruby-3.2.3/gems/railties-7.2.2.1/lib/rails/templates/rails/welcome/index.html.erb
  Rendered /Users/aleksey.volobuyev/.rvm/gems/ruby-3.2.3/gems/railties-7.2.2.1/lib/rails/templates/rails/welcome/index.html.erb (Duration: 0.7ms | GC: 0.0ms)
Completed 200 OK in 4ms (Views: 1.1ms | ActiveRecord: 0.0ms (0 queries, 0 cached) | GC: 0.0ms)


Started GET "/icon.png" for ::1 at 2025-08-09 09:27:24 +0300
  
ActionController::RoutingError (No route matches [GET] "/icon.png"):
  

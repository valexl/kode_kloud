# frozen_string_literal: true

class SequentInitialSchema < ActiveRecord::Migration[7.2]
  def up
    create_schema Sequent.configuration.event_store_schema_name, if_not_exists: true
    create_schema Sequent.configuration.view_schema_name, if_not_exists: true

    Sequent::Support::Database.with_search_path(Sequent.configuration.event_store_schema_name) do
      say 'Creating Sequent tables', true
      suppress_messages do
        execute <<~SQL
          CREATE TABLE command_types (id SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, type text UNIQUE NOT NULL);
          CREATE TABLE aggregate_types (id SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, type text UNIQUE NOT NULL);
          CREATE TABLE event_types (id SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, type text UNIQUE NOT NULL);

          CREATE TABLE commands (
              id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
              created_at timestamp with time zone NOT NULL,
              user_id uuid,
              aggregate_id uuid,
              command_type_id SMALLINT NOT NULL,
              command_json jsonb NOT NULL,
              event_aggregate_id uuid,
              event_sequence_number integer,
              FOREIGN KEY (command_type_id) REFERENCES command_types (id) ON UPDATE CASCADE
          ) PARTITION BY RANGE (id);

          CREATE TABLE aggregates (
              aggregate_id uuid NOT NULL PRIMARY KEY,
              events_partition_key text NOT NULL DEFAULT '',
              aggregate_type_id SMALLINT NOT NULL,
              created_at timestamp with time zone NOT NULL DEFAULT NOW(),
              UNIQUE (events_partition_key, aggregate_id),
              FOREIGN KEY (aggregate_type_id) REFERENCES aggregate_types (id) ON UPDATE CASCADE
          ) PARTITION BY RANGE (aggregate_id);

          CREATE TABLE aggregate_unique_keys (
              aggregate_id uuid NOT NULL,
              scope text NOT NULL,
              key jsonb NOT NULL,
              PRIMARY KEY (aggregate_id, scope),
              UNIQUE (scope, key),
              FOREIGN KEY (aggregate_id) REFERENCES aggregates (aggregate_id) ON UPDATE CASCADE ON DELETE CASCADE
          );

          CREATE TABLE events (
            aggregate_id uuid NOT NULL,
            partition_key text NOT NULL DEFAULT '',
            sequence_number integer NOT NULL,
            created_at timestamp with time zone NOT NULL,
            command_id bigint NOT NULL,
            event_type_id SMALLINT NOT NULL,
            event_json jsonb NOT NULL,
            xact_id bigint DEFAULT pg_current_xact_id()::text::bigint,
            PRIMARY KEY (partition_key, aggregate_id, sequence_number),
            FOREIGN KEY (partition_key, aggregate_id) REFERENCES aggregates (events_partition_key, aggregate_id)
                 ON UPDATE CASCADE ON DELETE RESTRICT,
            FOREIGN KEY (command_id) REFERENCES commands (id) ON UPDATE RESTRICT ON DELETE RESTRICT,
            FOREIGN KEY (event_type_id) REFERENCES event_types (id) ON UPDATE CASCADE
          ) PARTITION BY RANGE (partition_key);

          CREATE TABLE aggregates_that_need_snapshots (
            aggregate_id uuid NOT NULL PRIMARY KEY,
            snapshot_sequence_number_high_water_mark integer,
            snapshot_outdated_at timestamp with time zone,
            snapshot_scheduled_at timestamp with time zone,
            FOREIGN KEY (aggregate_id) REFERENCES aggregates (aggregate_id) ON UPDATE CASCADE ON DELETE CASCADE
          );

          COMMENT ON TABLE aggregates_that_need_snapshots IS 'Contains a row for every aggregate with more events than its snapshot threshold.';
          COMMENT ON COLUMN aggregates_that_need_snapshots.snapshot_sequence_number_high_water_mark
            IS 'The highest sequence number of the stored snapshot. Kept when snapshot are deleted to more easily query aggregates that need snapshotting the most';
          COMMENT ON COLUMN aggregates_that_need_snapshots.snapshot_outdated_at IS 'Not NULL indicates a snapshot is needed since the stored timestamp';
          COMMENT ON COLUMN aggregates_that_need_snapshots.snapshot_scheduled_at IS 'Not NULL indicates a snapshot is in the process of being taken';

          CREATE TABLE snapshot_records (
            aggregate_id uuid NOT NULL,
            sequence_number integer NOT NULL,
            created_at timestamptz NOT NULL,
            snapshot_type text NOT NULL,
            snapshot_json jsonb NOT NULL,
            PRIMARY KEY (aggregate_id, sequence_number),
            FOREIGN KEY (aggregate_id) REFERENCES aggregates_that_need_snapshots (aggregate_id)
                 ON UPDATE CASCADE ON DELETE CASCADE
          );

          CREATE TABLE saved_event_records (
            operation varchar(1) NOT NULL CHECK (operation IN ('U', 'D')),
            timestamp timestamptz NOT NULL,
            "user" text NOT NULL,
            aggregate_id uuid NOT NULL,
            partition_key text DEFAULT '',
            sequence_number integer NOT NULL,
            created_at timestamp with time zone NOT NULL,
            command_id bigint NOT NULL,
            event_type text NOT NULL,
            event_json jsonb NOT NULL,
            xact_id bigint,
            PRIMARY KEY (aggregate_id, sequence_number, timestamp)
          );
        SQL
      end

      say 'Creating table partitions', true
      suppress_messages do
        execute <<~SQL
          -- ### Configure partitions as needed
          CREATE TABLE commands_default PARTITION OF commands DEFAULT;
          -- CREATE TABLE commands_0 PARTITION OF commands FOR VALUES FROM (1) TO (100e6);
          -- CREATE TABLE commands_1 PARTITION OF commands FOR VALUES FROM (100e6) TO (200e6);
          -- CREATE TABLE commands_2 PARTITION OF commands FOR VALUES FROM (200e6) TO (300e6);
          -- CREATE TABLE commands_3 PARTITION OF commands FOR VALUES FROM (300e6) TO (400e6);

          -- ### Configure partitions as needed
          CREATE TABLE aggregates_default PARTITION OF aggregates DEFAULT;
          -- CREATE TABLE aggregates_0 PARTITION OF aggregates FOR VALUES FROM (MINVALUE) TO ('10000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_1 PARTITION OF aggregates FOR VALUES FROM ('10000000-0000-0000-0000-000000000000') TO ('20000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_2 PARTITION OF aggregates FOR VALUES FROM ('20000000-0000-0000-0000-000000000000') TO ('30000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_3 PARTITION OF aggregates FOR VALUES FROM ('30000000-0000-0000-0000-000000000000') TO ('40000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_4 PARTITION OF aggregates FOR VALUES FROM ('40000000-0000-0000-0000-000000000000') TO ('50000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_5 PARTITION OF aggregates FOR VALUES FROM ('50000000-0000-0000-0000-000000000000') TO ('60000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_6 PARTITION OF aggregates FOR VALUES FROM ('60000000-0000-0000-0000-000000000000') TO ('70000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_7 PARTITION OF aggregates FOR VALUES FROM ('70000000-0000-0000-0000-000000000000') TO ('80000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_8 PARTITION OF aggregates FOR VALUES FROM ('80000000-0000-0000-0000-000000000000') TO ('90000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_9 PARTITION OF aggregates FOR VALUES FROM ('90000000-0000-0000-0000-000000000000') TO ('a0000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_a PARTITION OF aggregates FOR VALUES FROM ('a0000000-0000-0000-0000-000000000000') TO ('b0000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_b PARTITION OF aggregates FOR VALUES FROM ('b0000000-0000-0000-0000-000000000000') TO ('c0000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_c PARTITION OF aggregates FOR VALUES FROM ('c0000000-0000-0000-0000-000000000000') TO ('d0000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_d PARTITION OF aggregates FOR VALUES FROM ('d0000000-0000-0000-0000-000000000000') TO ('e0000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_e PARTITION OF aggregates FOR VALUES FROM ('e0000000-0000-0000-0000-000000000000') TO ('f0000000-0000-0000-0000-000000000000');
          -- CREATE TABLE aggregates_f PARTITION OF aggregates FOR VALUES FROM ('f0000000-0000-0000-0000-000000000000') TO (MAXVALUE);

          -- ### Configure partitions as needed
          CREATE TABLE events_default PARTITION OF events DEFAULT;
          -- CREATE TABLE events_2023_and_earlier PARTITION OF events FOR VALUES FROM ('Y00') TO ('Y24');
          -- CREATE TABLE events_2024 PARTITION OF events FOR VALUES FROM ('Y24') TO ('Y25');
          -- CREATE TABLE events_2025 PARTITION OF events FOR VALUES FROM ('Y25') TO ('Y26');
          -- CREATE TABLE events_2026 PARTITION OF events FOR VALUES FROM ('Y26') TO ('Y27');
          -- CREATE TABLE events_2027_and_later PARTITION OF events FOR VALUES FROM ('Y27') TO ('Y99');
          -- CREATE TABLE events_aggregate PARTITION OF events FOR VALUES FROM ('A') TO ('Ag');
        SQL
      end

      say 'Creating indexes', true
      suppress_messages do
        execute <<~SQL
          CREATE INDEX aggregates_aggregate_type_id_idx ON aggregates (aggregate_type_id);
          CREATE INDEX commands_command_type_id_idx ON commands (command_type_id);
          CREATE INDEX commands_aggregate_id_idx ON commands (aggregate_id);
          CREATE INDEX commands_event_idx ON commands (event_aggregate_id, event_sequence_number);
          CREATE INDEX events_command_id_idx ON events (command_id);
          CREATE INDEX events_event_type_id_idx ON events (event_type_id);
          CREATE INDEX aggregates_that_need_snapshots_outdated_idx
                    ON aggregates_that_need_snapshots (snapshot_outdated_at ASC, snapshot_sequence_number_high_water_mark DESC, aggregate_id ASC)
                 WHERE snapshot_outdated_at IS NOT NULL;

        SQL
      end
    end
  end

  def down
    execute "DROP SCHEMA #{Sequent.configuration.view_schema_name} CASCADE"
    execute "DROP SCHEMA #{Sequent.configuration.event_store_schema_name} CASCADE"
  end
end
